<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PvP Ïò®ÎùºÏù∏ Ï≤¥Ïä§</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chess.js Library for game logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, getDocs, addDoc, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Expose Firebase components globally for the main script
        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, getDocs, addDoc, serverTimestamp, deleteDoc, setLogLevel
        };
    </script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#059669', // Emerald 600
                        'secondary': '#10b981', // Emerald 500
                        'accent': '#f59e0b', // Amber 500
                        'bg-main': '#f0fdf4', // Emerald 50
                    }
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', 'sans-serif';
            background-color: theme('colors.bg-main');
        }

        /* Chess Board Styles - Consistency Fix: added box-sizing */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            aspect-ratio: 1 / 1; /* Keep the board square */
            border: 4px solid #10b981; /* Accent border */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 480px; /* Limit max size on large screens */
        }
        
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5vmin; /* Responsive piece size */
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
            box-sizing: border-box; /* Ensure padding/border doesn't affect grid sizing */
        }

        .light {
            background-color: #f0d9b5;
        }

        .dark {
            background-color: #b58863;
        }

        .selected {
            background-color: #22c55e !important; /* Green 500 */
        }

        .possible-move {
            position: relative;
        }
        
        /* Highlight possible moves with a dot or circle */
        .possible-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3);
            pointer-events: none; /* Allows click to pass through to the square */
        }

        .selected.possible-move::after {
            background-color: rgba(255, 255, 255, 0.5); /* White dot on selected green square */
        }

        /* Piece Styling using Unicode */
        .piece {
            line-height: 1;
            font-size: 8vmin;
        }
        
        .randomizing-pulse {
            animation: pulse 0.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Responsive board size */
        @media (max-width: 640px) {
            .square {
                font-size: 5vmin;
            }
            .piece {
                font-size: 10vmin;
            }
            #board {
                max-width: 90vw;
            }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Î©îÏù∏ Ïª®ÌÖåÏù¥ÎÑà -->
    <div class="w-full max-w-xl bg-white shadow-2xl rounded-xl p-6 md:p-8 space-y-6">
        <h1 class="text-3xl font-extrabold text-primary text-center">
            ‚ôüÔ∏è Ïò®ÎùºÏù∏ PvP Ï≤¥Ïä§ 
        </h1>

        <!-- Ïú†Ï†Ä ID ÌëúÏãú -->
        <div class="text-xs text-center text-gray-500 break-words">
            ÎÇ¥ ID: <span id="user-id">Ïù∏Ï¶ù Ï§ë...</span>
        </div>
        
        <!-- Î°úÎî© Î∞è Ïù∏Ï¶ù ÏÉÅÌÉú -->
        <div id="loading-status" class="text-center text-accent font-semibold">
            Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï§ë...
        </div>

        <!-- Î£∏ Í¥ÄÎ¶¨ ÏòÅÏó≠ -->
        <div id="room-selection" class="hidden space-y-4">
            <h2 class="text-xl font-bold text-gray-700 text-center">Î∞© ÏÑ†ÌÉù</h2>
            
            <div id="create-room-container" class="flex flex-col md:flex-row gap-2">
                <input id="new-room-name" type="text" placeholder="ÏÉà Î∞© Ïù¥Î¶Ñ ÏûÖÎ†•" class="flex-grow p-2 border rounded-lg focus:ring-primary focus:border-primary">
                <button id="create-room-btn" class="px-4 py-2 bg-primary text-white font-semibold rounded-lg shadow hover:bg-green-700 transition duration-150">
                    Î∞© ÎßåÎì§Í∏∞ (ÎåÄÍ∏∞)
                </button>
            </div>

            <h3 class="text-lg font-semibold text-gray-600 mt-4">Ï∞∏Ïó¨ Í∞ÄÎä•Ìïú Î∞©</h3>
            <div id="room-list" class="max-h-60 overflow-y-auto border p-3 rounded-lg space-y-2">
                <!-- Room list items will be injected here -->
            </div>
        </div>

        <!-- Î°úÎπÑ/Í≤åÏûÑ ÏòÅÏó≠ -->
        <div id="game-area" class="hidden flex flex-col items-center space-y-4">
            <div id="room-info" class="text-center w-full p-2 bg-gray-100 rounded-lg">
                <p class="font-bold text-lg" id="current-room-name"></p>
                <!-- ÌîåÎ†àÏù¥Ïñ¥ ID ÌëúÏãúÎ•º ÏóÖÎç∞Ïù¥Ìä∏ÌïòÍ≥† Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏúÑÌïú ID Ï∂îÍ∞Ä -->
                <p class="text-sm">
                    Î∞±: <span id="white-player-id"></span> | Ìùë: <span id="black-player-id"></span>
                </p>
                <button id="leave-room-btn" class="text-red-500 text-xs mt-1 hover:underline">Î∞© ÎÇòÍ∞ÄÍ∏∞</button>
            </div>

            <!-- Ï≤¥Ïä§ Î≥¥Îìú -->
            <div id="board" class="w-full">
                <!-- Board will be rendered here -->
            </div>
            
            <!-- ÏÉÅÌÉú ÌëúÏãú Î∞è Ïï°ÏÖò Î≤ÑÌäº -->
            <div class="flex justify-between w-full max-w-[480px]">
                <button id="reset-button" class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg shadow hover:bg-gray-300 transition duration-150">
                    Í≤åÏûÑ Îã§Ïãú ÏãúÏûë (Î∞©Ïû•Îßå Í∞ÄÎä•)
                </button>
                <div id="game-status" class="text-lg font-bold text-primary">
                    Í≤åÏûÑ ÏãúÏûë ÎåÄÍ∏∞ Ï§ë...
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Firebase/App Initialization ---
        const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, 
                getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, where, getDocs, addDoc, serverTimestamp, deleteDoc, setLogLevel } = window.firebase;

        // Mandatorily provided global variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;
        
        // Firestore path helpers for public data
        const getRoomCollectionRef = () => {
            return collection(db, `artifacts/${appId}/public/data/chess_rooms`);
        };
        const getRoomDocRef = (roomId) => {
            return doc(db, `artifacts/${appId}/public/data/chess_rooms`, roomId);
        };

        // --- Global Game State ---
        const game = new Chess();
        let selectedSquare = null;
        let currentRoomId = null;
        let unsubscribeGameListener = null;
        let myColor = null; // 'w' or 'b' or null (undetermined/spectator)
        let isRandomizing = false; // Flag to prevent multiple randomization starts

        // --- UI Elements ---
        const boardEl = document.getElementById('board');
        const userIdEl = document.getElementById('user-id');
        const loadingStatusEl = document.getElementById('loading-status');
        const roomSelectionEl = document.getElementById('room-selection');
        const gameAreaEl = document.getElementById('game-area');
        const newRoomNameInput = document.getElementById('new-room-name');
        const createRoomBtn = document.getElementById('create-room-btn');
        const roomListEl = document.getElementById('room-list');
        const currentRoomNameEl = document.getElementById('current-room-name');
        const whitePlayerIdEl = document.getElementById('white-player-id');
        const blackPlayerIdEl = document.getElementById('black-player-id');
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const gameStatusEl = document.getElementById('game-status');
        const resetButton = document.getElementById('reset-button');
        
        // Ïú†ÎãàÏΩîÎìú Ï≤¥Ïä§ Í∏∞Ìò∏
        const pieces = {
            'p': '‚ôô', 'n': '‚ôò', 'b': '‚ôó', 'r': '‚ôñ', 'q': '‚ôï', 'k': '‚ôî',
            'P': '‚ôü', 'N': '‚ôû', 'B': '‚ôù', 'R': '‚ôú', 'Q': '‚ôõ', 'K': '‚ôö'
        };

        // --- Firebase Setup and Auth ---
        async function initializeFirebase() {
            try {
                // setLogLevel('Debug'); // Enable debug logging for Firestore
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                await new Promise(resolve => {
                    // Check initial auth state
                    const unsubscribe = onAuthStateChanged(auth, async (user) => {
                        unsubscribe(); 
                        if (user) {
                            userId = user.uid;
                        } else if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                            userId = auth.currentUser.uid;
                        } else {
                            // Fallback to anonymous sign-in if no custom token
                            const anonUser = await signInAnonymously(auth);
                            userId = anonUser.user.uid;
                        }
                        userIdEl.textContent = userId;
                        isAuthReady = true;
                        loadingStatusEl.classList.add('hidden');
                        resolve();
                    });
                });

                if (isAuthReady) {
                    renderBoard(); // Initial board structure
                    showRoomSelection();
                    setupRoomListListener();
                }

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                loadingStatusEl.textContent = `DB Ïó∞Í≤∞ Ïò§Î•ò: ${error.message}`;
                loadingStatusEl.classList.remove('text-accent');
                loadingStatusEl.classList.add('text-red-600');
            }
        }

        // --- Room Management ---

        function showRoomSelection() {
            roomSelectionEl.classList.remove('hidden');
            gameAreaEl.classList.add('hidden');
        }

        function showGameArea() {
            roomSelectionEl.classList.add('hidden');
            gameAreaEl.classList.remove('hidden');
        }

        async function createRoom() {
            if (!isAuthReady || currentRoomId) return;

            const roomName = newRoomNameInput.value.trim() || `Room by ${userId.substring(0, 8)}`;
            
            try {
                // Initial room state uses player1/player2 fields
                const newRoom = {
                    name: roomName,
                    fen: game.fen(), // Initial FEN
                    turn: 'w',
                    status: 'WAITING', // WAITING, JOINED, RANDOMIZING, PLAYING
                    player1Id: userId, // Creator
                    player2Id: null,
                    whitePlayerId: null, // Undetermined
                    blackPlayerId: null, // Undetermined
                    players: [userId],
                    createdBy: userId,
                    createdAt: serverTimestamp(),
                };

                const roomRef = await addDoc(getRoomCollectionRef(), newRoom);
                currentRoomId = roomRef.id;
                myColor = null; // Color determined later
                
                // Set game listener for the newly created room
                setupGameListener(currentRoomId);
            } catch (error) {
                console.error("Error creating room:", error);
                // Use custom UI for alerts
                gameStatusEl.textContent = `Î∞© ÏÉùÏÑ± Ïã§Ìå®: ${error.message}`;
                gameStatusEl.classList.add('text-red-600');
            }
        }

        async function joinRoom(roomId) {
            if (!isAuthReady || currentRoomId) return;

            try {
                const roomDocRef = getRoomDocRef(roomId);
                const roomSnapshot = await getDoc(roomDocRef);

                if (!roomSnapshot.exists()) {
                    // Use custom UI for alerts
                    gameStatusEl.textContent = 'Î∞©Ïù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.';
                    gameStatusEl.classList.add('text-red-600');
                    return;
                }
                const roomData = roomSnapshot.data();

                // Check if the room is joinable (must be WAITING and have only player1)
                if (roomData.status !== 'WAITING' || roomData.player2Id) {
                    gameStatusEl.textContent = 'Ïù¥ÎØ∏ Í∞ÄÎìù Ï∞ºÍ±∞ÎÇò Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏù∏ Î∞©ÏûÖÎãàÎã§.';
                    gameStatusEl.classList.add('text-red-600');
                    return;
                }
                
                // 1. Join as Player 2, set status to JOINED
                await setDoc(roomDocRef, {
                    player2Id: userId,
                    players: [roomData.player1Id, userId],
                    status: 'JOINED'
                }, { merge: true });
                
                currentRoomId = roomId;
                myColor = null; // Color determined later
                setupGameListener(currentRoomId);

                // 2. Immediately transition to RANDOMIZING state
                await setDoc(roomDocRef, { status: 'RANDOMIZING' }, { merge: true });

            } catch (error) {
                console.error("Error joining room:", error);
                gameStatusEl.textContent = `Î∞© Ï∞∏Ïó¨ Ïã§Ìå®: ${error.message}`;
                gameStatusEl.classList.add('text-red-600');
            }
        }
        
        async function leaveRoom() {
            if (!currentRoomId || !isAuthReady) return;

            try {
                const roomDocRef = getRoomDocRef(currentRoomId);
                const roomSnapshot = await getDoc(roomDocRef);
                const roomData = roomSnapshot.data();

                if (roomData) {
                    // I am Player 1 (Creator)
                    if (roomData.player1Id === userId) {
                        if (!roomData.player2Id) {
                            // Room is empty, delete it
                            await deleteDoc(roomDocRef);
                        } else {
                            // Transfer ownership: Player 2 becomes Player 1
                            await setDoc(roomDocRef, {
                                player1Id: roomData.player2Id,
                                player2Id: null,
                                whitePlayerId: null,
                                blackPlayerId: null,
                                status: 'WAITING',
                                createdBy: roomData.player2Id,
                                players: [roomData.player2Id]
                            }, { merge: true });
                        }
                    } else if (roomData.player2Id === userId) {
                        // I am Player 2, just leave
                        await setDoc(roomDocRef, {
                            player2Id: null,
                            whitePlayerId: null,
                            blackPlayerId: null,
                            status: 'WAITING',
                            players: [roomData.player1Id]
                        }, { merge: true });
                    }
                }
                
            } catch (error) {
                console.error("Error leaving/deleting room:", error);
            }
            
            // Cleanup local state
            if (unsubscribeGameListener) {
                unsubscribeGameListener();
                unsubscribeGameListener = null;
            }
            currentRoomId = null;
            myColor = null;
            game.reset();
            isRandomizing = false;
            showRoomSelection();
        }


        // --- Firestore Listeners ---
        
        /**
         * Real-time listener for the list of available rooms.
         */
        function setupRoomListListener() {
            if (!isAuthReady) return;
            const q = query(getRoomCollectionRef(), where('status', 'in', ['WAITING', 'JOINED', 'RANDOMIZING', 'PLAYING']));
            
            onSnapshot(q, (snapshot) => {
                roomListEl.innerHTML = '';
                let hasRooms = false;
                
                snapshot.forEach(doc => {
                    const room = doc.data();
                    const roomId = doc.id;
                    
                    // Do not show my current room in the list if the game is active
                    if (currentRoomId === roomId && room.status !== 'WAITING') return;

                    hasRooms = true;
                    
                    // Can join if WAITING and I'm not the creator (player1Id)
                    const canJoin = room.status === 'WAITING' && room.player1Id !== userId;
                    const statusText = room.status === 'WAITING' ? `ÎåÄÍ∏∞ (${room.player1Id.substring(0, 8)}...)` : 'ÌîåÎ†àÏù¥ Ï§ë';
                    
                    const roomItem = document.createElement('div');
                    roomItem.className = `flex justify-between items-center p-2 rounded-lg ${canJoin ? 'bg-indigo-100 hover:bg-indigo-200 cursor-pointer' : 'bg-gray-100 text-gray-500'}`;
                    roomItem.dataset.roomId = roomId;
                    roomItem.innerHTML = `
                        <span class="font-semibold">${room.name}</span>
                        <span class="text-sm">${statusText}</span>
                    `;

                    if (canJoin) {
                        roomItem.addEventListener('click', () => joinRoom(roomId));
                    }
                    roomListEl.appendChild(roomItem);
                });

                if (!hasRooms) {
                    roomListEl.innerHTML = '<p class="text-center text-gray-500">ÏÉùÏÑ±Îêú Î∞©Ïù¥ ÏóÜÏäµÎãàÎã§.</p>';
                }
            });
        }

        /**
         * Real-time listener for the current game room state.
         * @param {string} roomId 
         */
        function setupGameListener(roomId) {
            if (unsubscribeGameListener) {
                unsubscribeGameListener();
            }

            const roomDocRef = getRoomDocRef(roomId);
            unsubscribeGameListener = onSnapshot(roomDocRef, (docSnapshot) => {
                if (!docSnapshot.exists()) {
                    // Use custom UI for alerts
                    gameStatusEl.textContent = 'Î∞©Ïù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§. Î°úÎπÑÎ°ú ÎèåÏïÑÍ∞ëÎãàÎã§.';
                    gameStatusEl.classList.add('text-red-600');
                    leaveRoom();
                    return;
                }

                const roomData = docSnapshot.data();
                if (!roomData) return;

                // Determine my color based on final assignment
                myColor = null;
                if (roomData.whitePlayerId === userId) myColor = 'w';
                else if (roomData.blackPlayerId === userId) myColor = 'b';

                // Update UI based on room data
                currentRoomNameEl.textContent = roomData.name;
                
                // Show player IDs, use P1/P2 if not yet assigned colors
                const p1Sub = roomData.player1Id ? roomData.player1Id.substring(0, 8) + '...' : 'N/A';
                const p2Sub = roomData.player2Id ? roomData.player2Id.substring(0, 8) + '...' : 'ÎåÄÍ∏∞ Ï§ë';

                if (roomData.status === 'PLAYING') {
                    whitePlayerIdEl.textContent = roomData.whitePlayerId ? roomData.whitePlayerId.substring(0, 8) + '...' : 'Ïò§Î•ò';
                    blackPlayerIdEl.textContent = roomData.blackPlayerId ? roomData.blackPlayerId.substring(0, 8) + '...' : 'Ïò§Î•ò';
                } else {
                    // Use P1/P2 for pre-game states
                    whitePlayerIdEl.textContent = 'Í≤∞Ï†ï ÎåÄÍ∏∞ Ï§ë';
                    blackPlayerIdEl.textContent = 'Í≤∞Ï†ï ÎåÄÍ∏∞ Ï§ë';
                }
                
                // Special handling for RANDOMIZING state
                if (roomData.status === 'RANDOMIZING' && roomData.player1Id && roomData.player2Id) {
                    startColorRandomization(roomId, roomData);
                } else if (roomData.status === 'PLAYING') {
                    // Ensure randomization state is cleared when game starts
                    isRandomizing = false; 
                    gameStatusEl.classList.remove('randomizing-pulse');
                    whitePlayerIdEl.classList.remove('randomizing-pulse');
                    blackPlayerIdEl.classList.remove('randomizing-pulse');
                }

                // Load FEN and render board (only render the board when PLAYING)
                if (roomData.status === 'PLAYING') {
                    game.load(roomData.fen);
                    renderBoard();
                } else {
                    // When not playing, reset board visually or show a placeholder
                    game.reset();
                    renderBoard();
                }

                // Update game status
                updateStatus(roomData.status);
                showGameArea();

            }, (error) => {
                console.error("Game Listener Error:", error);
                gameStatusEl.textContent = "Í≤åÏûÑ ÏÉÅÌÉúÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Î∞©ÏùÑ ÎÇòÍ∞ëÎãàÎã§.";
                gameStatusEl.classList.add('text-red-600');
                leaveRoom();
            });
        }
        
        /**
         * ÏãúÍ∞ÅÏ†Å ÎûúÎç§Ìôî Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏãúÏûëÌïòÍ≥†, Ïï†ÎãàÎ©îÏù¥ÏÖòÏù¥ ÎÅùÎÇòÎ©¥ ÏÉâÏÉÅÏùÑ ÌôïÏ†ïÌï©ÎãàÎã§.
         */
        async function startColorRandomization(roomId, roomData) {
            if (isRandomizing) return;
            isRandomizing = true;
            
            // 1. Visual Animation Setup
            let animationCount = 0;
            const animationDuration = 3000; // 3 seconds
            
            gameStatusEl.classList.add('randomizing-pulse', 'text-indigo-600');
            whitePlayerIdEl.classList.add('randomizing-pulse');
            blackPlayerIdEl.classList.add('randomizing-pulse');

            const animationInterval = setInterval(() => {
                const p1Sub = roomData.player1Id.substring(0, 8) + '...';
                const p2Sub = roomData.player2Id.substring(0, 8) + '...';
                
                // Alternately show who gets which color
                if (animationCount % 2 === 0) {
                    whitePlayerIdEl.textContent = p1Sub;
                    blackPlayerIdEl.textContent = p2Sub;
                } else {
                    whitePlayerIdEl.textContent = p2Sub;
                    blackPlayerIdEl.textContent = p1Sub;
                }
                
                gameStatusEl.textContent = "ÏÉâÏÉÅ Í≤∞Ï†ï Ï§ë... Î£∞Î†õÏùÑ ÎèåÎ¶ΩÎãàÎã§!";

                animationCount++;
            }, 150);


            // 2. Wait for animation time
            await new Promise(resolve => setTimeout(resolve, animationDuration));
            
            clearInterval(animationInterval);
            
            // 3. Determine and Write Final Colors (Only the creator/player1 should perform the write)
            if (roomData.createdBy === userId) {
                const players = [roomData.player1Id, roomData.player2Id];
                const whiteIndex = Math.floor(Math.random() * 2); // 0 or 1
                
                const finalWhiteId = players[whiteIndex];
                const finalBlackId = players[1 - whiteIndex];
                
                await setDoc(getRoomDocRef(roomId), {
                    whitePlayerId: finalWhiteId,
                    blackPlayerId: finalBlackId,
                    status: 'PLAYING' // Transition to PLAYING
                }, { merge: true });
            }
            
            // Note: The onSnapshot listener will handle the transition to PLAYING and UI cleanup
        }


        /**
         * Ï≤¥Ïä§ÌåêÏùÑ Î†åÎçîÎßÅÌïòÍ≥† Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÎ•º ÏÑ§Ï†ïÌï©ÎãàÎã§.
         */
        function renderBoard() {
            boardEl.innerHTML = '';
            const boardState = game.board();

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const squareEl = document.createElement('div');
                    const squareName = String.fromCharCode('a'.charCodeAt(0) + c) + (8 - r);
                    const isLight = (r + c) % 2 === 0;

                    // Board must be flipped for Black player for better view
                    let boardIndexR = r;
                    let boardIndexC = c;
                    if (myColor === 'b') {
                        boardIndexR = 7 - r;
                        boardIndexC = 7 - c;
                    }
                    const flippedSquareName = String.fromCharCode('a'.charCodeAt(0) + boardIndexC) + (8 - boardIndexR);

                    squareEl.className = `square flex items-center justify-center ${isLight ? 'light' : 'dark'} transition-all`;
                    squareEl.dataset.square = flippedSquareName;

                    const piece = game.get(flippedSquareName);
                    
                    // Î™®Îì† Ïπ∏Ïóê Piece element (placeholder ÎòêÎäî Ïã§Ï†ú Îßê)Î•º ÎßåÎì≠ÎãàÎã§.
                    const pieceEl = document.createElement('span');
                    pieceEl.className = 'piece'; 
                    
                    if (piece) {
                        // Ïã§Ï†ú Îßê
                        pieceEl.style.color = piece.color === 'w' ? '#FFFFFF' : '#000000';
                        pieceEl.style.textShadow = piece.color === 'w' ? '0 0 3px #333' : 'none'; 
                        pieceEl.textContent = pieces[piece.color === 'w' ? piece.type.toUpperCase() : piece.type.toLowerCase()];
                    } else {
                        // ÎßêÏù¥ ÏóÜÎäî Ïπ∏: Ìà¨Î™ÖÌïú ÌîåÎ†àÏù¥Ïä§ ÌôÄÎçîÎ•º ÏÇ¨Ïö©Ìï¥ ÎÑàÎπÑ/ÎÜíÏù¥Î•º Ïú†ÏßÄÌï©ÎãàÎã§.
                        pieceEl.textContent = '‚ôü'; 
                        pieceEl.style.visibility = 'hidden'; 
                    }
                    
                    squareEl.appendChild(pieceEl);

                    squareEl.addEventListener('click', handleSquareClick);
                    boardEl.appendChild(squareEl);
                }
            }
        }

        /**
         * ÏÑ†ÌÉùÎêú ÎßêÏùò Í∞ÄÎä•Ìïú ÏõÄÏßÅÏûÑÏùÑ ÌïòÏù¥ÎùºÏù¥Ìä∏Ìï©ÎãàÎã§.
         * @param {string} squareName - ÏÑ†ÌÉùÎêú Ïπ∏Ïùò Ïù¥Î¶Ñ (Ïòà: 'e2').
         */
        function highlightMoves(squareName) {
            document.querySelectorAll('.possible-move, .selected').forEach(el => {
                el.classList.remove('possible-move');
                el.classList.remove('selected');
            });

            if (!squareName) return;
            
            const moves = game.moves({ square: squareName, verbose: true });

            document.querySelector(`[data-square="${squareName}"]`).classList.add('selected');

            moves.forEach(move => {
                const targetEl = document.querySelector(`[data-square="${move.to}"]`);
                if (targetEl) {
                    targetEl.classList.add('possible-move');
                }
            });
        }

        /**
         * Ï≤¥Ïä§Ìåê Ïπ∏ ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
         * @param {Event} event - ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏.
         */
        async function handleSquareClick(event) {
            if (!currentRoomId || !myColor || game.game_over()) return;
            
            const clickedSquare = event.currentTarget.dataset.square;
            const piece = game.get(clickedSquare);

            // 1. ÌÑ¥ ÌôïÏù∏: ÎÇ¥ Ï∞®Î°ÄÍ∞Ä ÏïÑÎãàÎ©¥ ÏïÑÎ¨¥Í≤ÉÎèÑ Ìï† Ïàò ÏóÜÏùå
            if (game.turn() !== myColor) {
                console.log("Not your turn.");
                return;
            }

            if (selectedSquare) {
                // 2. Ïù¥ÎØ∏ ÎßêÏù¥ ÏÑ†ÌÉùÎêú ÏÉÅÌÉú: Ïù¥Îèô ÏãúÎèÑ
                const tempGame = new Chess(game.fen());
                const moveResult = tempGame.move({ 
                    from: selectedSquare, 
                    to: clickedSquare, 
                    promotion: 'q' // ÌÄ∏ÏúºÎ°ú Í≥†Ï†ï ÏäπÏßÑ
                });

                if (moveResult) {
                    // Ïú†Ìö®Ìïú Ïù¥Îèô: FirestoreÏóê ÏóÖÎç∞Ïù¥Ìä∏
                    selectedSquare = null;
                    highlightMoves(null);
                    
                    const roomDocRef = getRoomDocRef(currentRoomId);
                    await setDoc(roomDocRef, {
                        fen: tempGame.fen(),
                        turn: tempGame.turn(),
                    }, { merge: true });
                    
                } else {
                    // Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïù¥Îèô: ÏÑ†ÌÉù Î≥ÄÍ≤Ω ÎòêÎäî Ìï¥Ï†ú
                    if (piece && piece.color === myColor) {
                        selectedSquare = clickedSquare;
                        highlightMoves(selectedSquare);
                    } else {
                        selectedSquare = null;
                        highlightMoves(null);
                    }
                }
            } else {
                // 3. ÎßêÏù¥ ÏÑ†ÌÉùÎêòÏßÄ ÏïäÏùÄ ÏÉÅÌÉú: ÎÇ¥ Îßê ÏÑ†ÌÉù ÏãúÎèÑ
                if (piece && piece.color === myColor) {
                    selectedSquare = clickedSquare;
                    highlightMoves(selectedSquare);
                }
            }
        }

        /**
         * Í≤åÏûÑ ÏÉÅÌÉú Î©îÏãúÏßÄÎ•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
         * @param {string} roomStatus - FirestoreÏùò room.status
         */
        function updateStatus(roomStatus) {
            let status = '';
            let statusClass = 'text-gray-800';
            
            resetButton.classList.add('hidden'); // Default hide

            if (roomStatus === 'WAITING' || roomStatus === 'JOINED') {
                status = 'ÏÉÅÎåÄÎ∞© ÎåÄÍ∏∞ Ï§ë...';
                statusClass = 'text-accent';
                // Remove randomization animation if not in that state
                gameStatusEl.classList.remove('randomizing-pulse', 'text-indigo-600');
                whitePlayerIdEl.classList.remove('randomizing-pulse');
                blackPlayerIdEl.classList.remove('randomizing-pulse');
            } else if (roomStatus === 'RANDOMIZING') {
                status = 'ÏÉâÏÉÅ Í≤∞Ï†ï Ï§ë...'; // Text updated by startColorRandomization
                statusClass = 'text-indigo-600';
            } else if (roomStatus === 'PLAYING') {
                resetButton.classList.remove('hidden');
                
                // Clear randomization classes
                gameStatusEl.classList.remove('randomizing-pulse', 'text-indigo-600');
                whitePlayerIdEl.classList.remove('randomizing-pulse');
                blackPlayerIdEl.classList.remove('randomizing-pulse');

                if (game.in_checkmate()) {
                    status = (game.turn() === 'w' ? "üéâ ÌùëÎèå ÏäπÎ¶¨ (Ï≤¥ÌÅ¨Î©îÏù¥Ìä∏)! üéâ" : "üèÜ Î∞±Îèå ÏäπÎ¶¨ (Ï≤¥ÌÅ¨Î©îÏù¥Ìä∏)! üèÜ");
                    statusClass = game.turn() === 'w' ? 'text-red-600' : 'text-primary';
                } else if (game.in_draw()) {
                    status = 'Î¨¥ÏäπÎ∂Ä!';
                    statusClass = 'text-accent';
                } else {
                    status = 'Ï∞®Î°Ä: ' + (game.turn() === 'w' ? 'Î∞±Îèå' : 'ÌùëÎèå') + (game.turn() === myColor ? ' (ÎÇò)' : ' (ÏÉÅÎåÄ)');
                    statusClass = game.turn() === 'w' ? 'text-primary' : 'text-black';
                    if (game.in_check()) {
                        status += ' - Ï≤¥ÌÅ¨!';
                    }
                }
            }
            
            gameStatusEl.textContent = status;
            gameStatusEl.className = `text-lg font-bold ${statusClass}`;
        }
        
        async function resetGame() {
            if (!currentRoomId || !isAuthReady) return;

            try {
                const roomDocRef = getRoomDocRef(currentRoomId);
                const roomSnapshot = await getDoc(roomDocRef);
                const roomData = roomSnapshot.data();

                // Î∞©Ïû•(createdBy)Îßå Î¶¨ÏÖã Í∞ÄÎä•ÌïòÎèÑÎ°ù Ï†úÌïú
                if (roomData.createdBy !== userId) {
                    // Use custom UI for alerts
                    gameStatusEl.textContent = "Î∞©Ïû•(Î∞©ÏùÑ ÎßåÎì† ÏÇ¨Îûå)Îßå Í≤åÏûÑÏùÑ Î¶¨ÏÖãÌï† Ïàò ÏûàÏäµÎãàÎã§.";
                    gameStatusEl.classList.add('text-red-600');
                    return;
                }

                // Î¶¨ÏÖã
                game.reset();
                await setDoc(roomDocRef, {
                    fen: game.fen(),
                    turn: 'w',
                    status: 'PLAYING',
                    // ÌîåÎ†àÏù¥Ïñ¥Îäî Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
                }, { merge: true });

            } catch (error) {
                console.error("Error resetting game:", error);
                gameStatusEl.textContent = `Í≤åÏûÑ Î¶¨ÏÖã Ïã§Ìå®: ${error.message}`;
                gameStatusEl.classList.add('text-red-600');
            }
        }


        // --- Event Listeners ---
        
        createRoomBtn.addEventListener('click', createRoom);
        leaveRoomBtn.addEventListener('click', leaveRoom);
        resetButton.addEventListener('click', resetGame);


        // --- Initial Execution ---
        window.onload = () => {
             // Firebase Ï¥àÍ∏∞Ìôî Î∞è Ïù∏Ï¶ù ÏãúÏûë
             initializeFirebase();
        };

    </script>
</body>
</html>